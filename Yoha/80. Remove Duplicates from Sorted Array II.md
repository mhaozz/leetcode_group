#### 要求

给出一个排序的数组对其进行修改，要求每个元素出现次数小于等于两次，且修改过程是in-place。

```
input:[1,1,1,2,2,3]
output:[1,1,2,2,3]

input:[0,0,1,1,1,1,2,3,3]
output:[0,0,1,1,2,3,3]
```

#### 思路

当前后元素不同时，自然要将该元素存放到该在的位置上；当前后元素相同时，根据其出现次数来决定是存放还是跳过。

此时就会出现一个问题，怎么表示元素的最终位置。

用一个idx来表示元素最终位置，它在上述不同情况下可变可不变

```
 idx = 1, i = 1 [1,1,1,2,2,3]
 idx = 2, i = 2 [1,1,1,2,2,3]
 idx = 2, i = 3 [1,1,1,2,2,3]
 idx = 3, i = 4 [1,1,2,2,2,3]
 idx = 4, i = 5 [1,1,2,2,3,3]
```

#### 代码

```java
public int removeDuplicates(int[] nums) {
        int idx = 1;
        int cnt = 1;
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] == nums[i-1]) {
                cnt++;
                if (cnt <= 2) {
                    nums[idx++] = nums[i];
                }
            } else {
                cnt = 1;
                nums[idx++] = nums[i];
            }
        }
        return idx;
    }
```

这里返回的是idx，也就是修改后数组的有效长度，这个有效长度就是按照题目要求对数组进行修改后的长度。

可能在方法调用外部会对这个数组进行遍历打印，类似于

```
for (int i = 0; i < idx; i++) {
	System.out.println(nums[i]);
}
// 1,1,2,2,3
```

